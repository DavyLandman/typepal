module examples::pascal::Plugin

import ParseTree;
import util::IDE;
import IO;

import analysis::typepal::TypePal;

import examples::pascal::Syntax;
import examples::pascal::Checker;

import util::Reflective;
import lang::manifest::IO;

data PascalManifest 
 = pascalManifest(
      list[str] Source = ["src"],
      list[str] Libraries = ["lib"]
    );        
 
private loc configFile(loc file) =  project(file) + "META-INF" + "RASCAL.MF"; 

private loc project(loc file) {
   assert file.scheme == "project";
   return |project:///|[authority = file.authority];
}

PathConfig getDefaultPathConfig() = pathConfig(srcs = [], libs = []);

PathConfig config(loc file) {
   assert file.scheme == "project";

   p = project(file);
   cfgFile = configFile(file);
   mf = readManifest(#PascalManifest, cfgFile); 
   
   cfg = getDefaultPathConfig();
   
   cfg.srcs += [ p + s | s <- mf.Source];
   cfg.libs += [ p + l | l <- mf.Libraries];
   
   return cfg;
}

data TypePalSummary(
    map[loc, AType] types = (),        // maps locations in the tree to control types
    rel[loc from, loc to] useDef = {}, // relation frome each use to its definition
    set[Message] messages = {}        // messages generated by checker
) = \module();

TypePalSummary makeSummary(loc root, TModel model)  {
    return \module(
        types=getFacts(model), 
        useDef=getUseDef(model), 
        messages={*getMessages(model)}
    );
}

str getModuleName(start[Program] t) = "<m.programHeading.id>"
    when t has top && Program m := t.top;

default str getModuleName(Tree t) = "";


     
start[Program] parsePascalProgram(str s, loc l) = parse(#start[Program], s, l, allowAmbiguity = true);

TModel pascalTModelForTree(Tree pt, str programName, PathConfig pcfg, bool debug){
    if(pt has top) pt = pt.top;
    
    c = newCollector(programName, pt, config=pascalConfig());
    pascalPreCollectInitialization(pt, c);
    collect(pt, c);
    return newSolver(pt, c.run()).run();
}

Tree checkPascal(Tree input)
    = check(makePascalSummary, input);  
    
TypePalSummary makePascalSummary(Tree t, PathConfig pcfg) 
    = makeSummary((t@\loc).top, pascalTModelForTree(t, getModuleName(t), pcfg, true));  

Tree check(TypePalSummary (Tree, PathConfig) calcSummary, Tree input) {
  println("Checking: <input@\loc>"); 
  pcfg = config(input@\loc);
  println("pcfg = <pcfg>");
  summary = calcSummary(input, pcfg);
  types = summary.types;
  
  return input[@messages=summary.messages]
              [@hyperlinks=summary.useDef]
              [@docs=(l:"<prettyAType(types[l])>" | l <- types)]
         ;
} 

Contribution commonSyntaxProperties 
    = syntaxProperties(
        fences = {<"{","}">,<"(",")">}, 
        lineComment = "//", 
        blockComment = <"/*","*","*/">
    );



void registerPascal() {
    registerLanguage("Pascal", "pascal", parsePascalProgram);
    registerContributions("Pascal", {
        commonSyntaxProperties,
        treeProperties(hasQuickFixes = false),
        annotator(checkPascal)
    });
    
}

void main() {
    registerPascal();
}
