# TypePal: Type Checking & Inference Made Easy 

.Synopsis
TypePal is a framework for type checking and type inference

.Usage

.Details
Architecture

.Description
Many type checkers have already been written in Rascal with good results. However, type checkers for different languages have a lot in common and address similar
questions:

* How to handle declarations of names, in particular their scope and uses?
* How to distinguish the roles names can play, e.g., names of functions, constants or variables?
* How to handle imports and multiple name spaces?
* How to associate requirements/constraints relevant for type checking with the syntax definition of the language being type checked?
* How to represent the types that occur in a program?
* How to handle global or local type inference?
* How to give precise error messages (and avoid duplicates)?
* How to extract information that is useful for later compiler stages or the IDE for, e.g., code generation, use-def information or name completion?

TypePal is a declarative framework that operates on a model of the analysed program consisting of _facts_ and _requirements_.
Unsurprisingly, this is called the _FRModel_ of the program: facts describe elementary observations (e.g., an integer literal is of type integer) 
and requirements impose restrictions on the types of program fragments (e.g., if the expression on the right-hand side of an assignment has type integer,
then the type of the variable on the left-hand side should be compatible with the type integer). A requirement may be violated and this will generate
an error message. If a requirement is satisfied, this may lead to the creation of new facts that may help to determine the status of other requirements.

Technically, TypePal uses _scope graphs_ for expressing definition and use of names (including their role, scope, name space, and visibility),
and _constraints_ to describe requirements. These constraints are such that they can express either type checking or type inference, or a mixture thereof.

The TypePal framework is highly parameterized as we will see below.

.Examples


.Benefits

.Pitfalls
