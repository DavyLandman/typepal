# FRBuilder: how to create an FRModel

.Synopsis
An `FRBuilder` enables the incremental addition of facts and requirements to an `FRModel`.

.Description
The life cycle of the `FRBuilder` looks like this:

image::FRBuilder.png[500,500,align="center"]

First, a fresh `FRBuilder` is created by `newFRBuilder`, let's assign it to variable `frb`.

Next, a dozen of functions is available to add facts and requirements. 
The FRBuilder is actually represented as a data type with a single constructor
that has fields that correspond to the functions provided by the builder.
For instance, calling the `define` function on the FRBuilder we just created amounts to: `frb.define(the-arguments-of-define)`.
The builder functions are applied repeatedly until all
information has been extracted from the source program.

Finally, `done` creates the desired `FRModel` that will be used for validation.

== Define a name
There is a single function called `define` to add the definition of a name to the FRModel:
[source,rascal]
----
Tree define (Tree scope, str id, IdRole idRole, Tree def, DefInfo info);
----

* `scope` is the scope in which the name is to be defined.
* `id` is the textual appearance of the name.
* `idRole` is the role played by the name.
* `def` is the part of the parse tree that corresponds to the definition of the name.
* `info` is information to be associated with this definition.


IMPORTANT: `define` returns a Tree as value. That returned tree will be used as the current scope
while processing all subtrees of the definition, i.e., the value of `def` above.

== Use of a name

There are four functions to describe the occurrence of a name in a parse tree as a use.

=== Elementary use
The most elementary use of a name is described by:
[source,rascal]
----
void use(Tree scope, Tree occ, set[IdRole] idRoles) use;
----
In a given `scope` the parse tree `occ` is a use to be resolved in one of the given roles `idRoles`.

=== Reference
The next version of use, represents a use that refers to another tree using a specific path label:
[source,rascal]
----
void use_ref(Tree scope, Tree occ, set[IdRole] idRoles, PathLabel pathLabel);
----

=== Qualified name

Next we consider the use of qualified names, i.e., a list of identifiers that will be resolved from left to right.
We will call these identifiers (except the last one) qualifiers and the last one the qualified identifier.
[source,rascal]
----
void use_qual(Tree scope, list[str] ids, Tree occ, set[IdRole] idRoles, set[IdRole] qualifierRoles);
----

Here `ids` is the qualified name, `occ` is the actual occurrences, and there two sets of roles:
idRoles are the possible roles for the qualified identifiers and `qualifierRoles are the possible roles for the qualifiers.

=== Qualified reference
[source,rascal]
----
void use_qual_ref(Tree scope, list[str] ids, Tree occ, set[IdRole] idRoles, set[IdRole] qualifierRoles, PathLabel pathLabel);   
----  





== Facts

== Requirements

== Overloading

== Type variables

== Errors