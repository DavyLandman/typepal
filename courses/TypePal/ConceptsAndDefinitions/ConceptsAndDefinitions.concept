# Concepts and Definitions

.Synopsis
Concepts and definitions needed to better understand TypePal.

== Names
The syntax of a source language may impose various restrictions on the names 
that can occur in a program. They amount to including or excluding specific characters 
for various occurrences of names in the program. One example is the requirement in Java that class names
start with an upper case letter. TypePal is agnostic of such conventions and represents 
each name as a string. _Qualified names_ are also supported.

== Roles

Names can play different _roles_ in a program, e.g., as name of a module, method, constant or variable.
Roles are modelled by the data type `IdRole` that has to be extended by the author of the typechecker.
Here is an example where roles are introduced for constants, variables, formal parameters and functions:

[source,rascal]
----
data IdRole
    = constantId()
    | variableId()
    | formalId()
    | functionId()
    ;
----


== Trees

The data type `Tree` (add ref) is used to represent all parse trees that can be generated for any syntax described in Rascal.
`Tree` is also a super type of any syntactic construct that may occur in a parse tree. In TypePal we use `Tree` to uniquely identify
a definition or a scope.

== Scopes
A scope is a region of a program that delimits where the definition of a name is applicable.
A name is defined in the scope where it is defined and in all nested subscopes, unless one of these subscopes
redefines that same name. In that case, the inner definition applies inside that nested scope (and its subscopes).
Scopes are represented by the subtree of the parse tree that corresponds to their textual extent.

== Types
The type to be associated with names varies widely for different programming languages and has to be provided by the typechecker author.
TypePal provides the data type `AType` that is to be extended:

[source,rascal]
----
data AType
    = tvar(loc name)                  //<1>
    | useType(Use use)                //<2>
    | listType(list[AType] atypes)    //<3>
    ;
----

<1> `tvar` represents a type variable (used for type inference) and is only used internally. 
<2> `useType` can be used to represent a type that uses another name as type. 
<3> `listType` is used to represent lists of types and is used both internally in TypePal but can also be used in typechecker definitions.

The typechecker author has to provide a function to convert `AType`s to string (it is used create readable error messages):
[source,rascal]
----
str AType2String(AType atype);
----

== DefInfo

When defining a name, we usually want to associate information with it such as the type of the defined name.
TypePal provides the data type `DefInfo` for this purpose:

[source,rascal]
----
data DefInfo
    = noDefInfo()                                       //<1>
    | defInfo(AType atype)                              //<2>
    | defInfo(list[Tree] dependsOn, AType() getAType)   //<3>
    ;
----
<1> No information associated with definition.
<2> Explicitly given AType associated with definition.
<3> Type of definition depends on the type of the entities given in `dependsOn`, when those are known, 
    `getAType` can construct the type of this definition. `getAType` will only be called by TypePal during constraint solving.

== Path
TypePal is based on scope graphs that are not only based on syntactic containment of scopes but can also express semantic 
connections between parse trees. Connections are labelled path, with user-defined labels.  Here is an example
of a path label to mark an import path between two parse trees.
[source,rascal]
----
data PathLabel
    = importsLabel()
    ;
----

Paths play a prominent role in the resolution of qualified names.

== Name Resolution
Name resolution is based on the principle: __syntactic resolution first, semantic resolution second__.
This means that we first search for a definition in the current parse tree and only when that fails 
we follow semantic path to other trees (either in the current tree or in other trees):

* First the current scope in which the name is used is searched for a definition.
* If this fails surrounding scopes are searched.
* If this fails semantic paths in the same parse tree or to other parse trees are searched, such as, for instance, 
  provided by an import statement.

This is illustrated below, where a name occurrence O 

image::NameResolution.png[500,500,align="center"]

IMPORTANT: Name resolution need not have a unique solution. 
Therefore the author can extend TypePal by writing functions to filter valid solutions.